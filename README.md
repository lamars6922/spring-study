# spring-study
교재 : 코드로 배우는 스프링 웹 프로젝트
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PART 1 : 스프링 개발 환경 구축
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JDK 1.8

STS(Spring Tool Suite) 플러그인

Tomcat 9

Maven 기반

Lombok 라이브러리 : Java 개발 시 자주 사용하는 getter/setter, toString(), 생성자 등을 자동으로 생성해 줌.

Oracle Database 연동 (11g Express 버전)

SQL Developer 설치

JDBC 연결

커넥션 풀(여러 명의 사용자를 동시에 처리해야 하는 웹 애플리케이션의 경우 사용) 설정

MyBatis 연동

ex00 : XML 기반

jex00 : JAVA 기반
(@Configuration 어노테이션을 이용해서 해당 클래스의 인스턴스를 이용해서 설정 파일을 대신함.)
(root-context.xml -> RootConfig.java, web.xml -> WebConfig.java)

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
스프링의 주요 특징
1. POJO 기반의 구성
2. 의존성 주입(DI)을 통한 객체 간의 관계 구성
3. AOP(Aspect-Oriented-Programming) 지원
4. 편리한 MVC 구조
5. WAS의 종속적이지 않은 개발 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
사용된 어노테이션
Lombok 관련 :
1. @Setter : setter 메서드를 생성해주는 역할
2. @Data : @ToString, @EqualsAndHashCode, @Getter/@Setter, @RequiredArgsConstructor를 모두 결합한 형태로 한번에 자주 사용되는 모든 메서드들을 생성할 수 있다.
3. @Log4j : 로그 객체럴 생성

Spring 관련 :
1. @Component : 해당 클래스가 스프링에서 객체로 만들어서 관리하는 대상임을 명시함.(@ComponentScan : @Component가 있는 클래스를 스프링이 읽음)
2. @Autowired : 스프링 내부에서 자신이 특정한 객체의 의존적이므로 자신에게 해당 타입의 빈을 주입해주라는 표시.

Test 관련 :
1. @ContextConfiguration : 스프링이 실행되면서 어떤 설정 정보를 읽어 들여야 하는지를 명시합니다.
2. @Runwith : 테스트 시 필요한 클래스를 지정합니다.(스프링은 SpringJUnit4ClassRunner 클래스가 대상)
3. @Test : junit에서 해당 메서드가 jUnit 상에서 단위 테스트의 대상인지 알려줍니다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PART 2 : 스프링 MVC 설정
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
스프링 MVC 프로젝트를 구성해서 사용한다는 의미는 내부적으로는 root-context.xml로 사용하는 일반 Java 영역(흔히 POJO(Plain Old Java Object))과 
servlet-context.xml로 설정하는 Web 관련 영역을 같이 연동해서 구동하게 됩니다. WebApplicationContext라는 존재는 기존의 구조에 MVC 설정을 포함하는 구조로 만들어짐.

XML 기반 : ex01, Java 기반 : jex01

jex01 : ServletConfig 클래스는 기존의 servlet-context.xml에 설정된 모든 내용을 담아야하는데, 
1. @EnableWebMvc 어노테이션과 WebMvcConfigurer 인터페이스를 구현하는 방식
2. @Configuration과 WebMvcConfigurationSupport 클래스를 상속하는 방식-일반 @Configuration 우선 순위가 구분되지 않는 경우에 사용

예제는 1번 방식으로 제작함.
WebMvcConfigurer는 스프링 MVC와 관련된 설정을 메서드로 오버라이드 하는 형태를 이용할 때 사용합니다.

예제 프로젝트의 로딩 구조
프로젝트 구동 시 관여하는 XML은 web.xml, root-context.xml, servlet-context.xml 파일입니다. web.xml은 Tomcat 구동과 관련된 설정이고, 나머지 두 파일은 스프링과 관련된 설정입니다.

Web.xml : 가장 먼저 구동되는 Context Listener가 등록되어 있습니다. <context-param>에는 root-context.xml의 경로가 설정되어 있고, 
<listener>에는 스프링 MVC의 ContextLoaderListener가 등록되어 있는데 해당 웹 애플리케이션 구동 시 같이 동작함.
  
root-context.xml : 파일에 있는 빈(Bean) 설정들이 동작하게 됩니다. 정의된 객체(Bean)들은 스프링의 영역(context) 안에 생성되고 객체들 간의 의존성이 처리됩니다. 
처리 후에는 스프링 MVC에서 사용하는 DispatcherServlet이라는 서블릿과 관련된 설정이 동작합니다.
  
servlet-context.xml : DispatcherServlet에서 XmlWebApplicationContext를 이용해서 servlet-context.xml를 로딩하고 해석하기 시작함. 
이 과정에서 등록된 객체(Bean)들은 기존에 만들어진 객체(Bean)들과 같이 연동하게 됩니다.
  
스프링 MVC의 기본 사상 : Servlet/JSP에서는 HttpServletRequest/HttpServletResponse라는 타입의 객체를 이용해 브라우저에서 전송한 정보를 처리하는 방식입니다.
스프링 MVC의 경우 하나의 계층을 더하는 형태가 됩니다.
ㅁ 개발자의 코드 영역 <-> Spring MVC <-> Servlet/JSP
스프링 MVC를 이용하게 되면 개발자들은 직접적으로 HttpServletRequest/HttpServletResponse 등과 같이 Servlet/JSP의 API를 사용할 필요성이 현저하게 줄어듭니다.
스프링은 중간에 연결 역할을 하기 때문에 이러한 코드를 작성하지 않고도 원하는 기능을 구현할 수 있게 됩니다.
  
스프링 MVC의 특정한 클래스를 상속하거나 인터페이스를 구현하는 형태로 개발할 수 있었지만, 스프링 2.5버전부터 등장한 어노테이션 방식으로 최근 개발에는 
어노테이션이나 XML 등의 설정만으로 개발이 가능하게 되었습니다.
  
모델2와 스프링 MVC : 스프링 MVC는 '모델 2'라는 방식으로 처리되는 구조입니다. 모델 2방식은 쉽게 말해서 '로직과 화면을 분리'하는 스타일의 개발 방식입니다.
  
  ![11](https://user-images.githubusercontent.com/57030114/122504823-070c7380-d036-11eb-9bbf-a8161e02d5a5.PNG)

  모델 2방식에서 사용자의 Request는 특별한 상황이 아닌 이상 먼저 Controller를 호출하게 됩니다. 
  설계의 가장 중요한 이유는 나중에 View를 교체하더라도 사용자가 호출하는 URL 자체에 변화가 없게 만들어 주기 때문입니다. 
  컨트롤러는 데이터를 처리하는 존재를 이용해서 데이터(Model)를 처리하고 Response 할 때 필요한 데이터(Model)를 View 쪽으로 전달하게 됩니다. 
  Servlet을 이용하는 경우 개발자들은 Servlet API의 RequestDispatcher 등을 이용해서 이를 직접 처리해 왔지만 스프링 MVC는 내부에서 이러한 처리를 하고, 
  개발자들은 스프링 MVC의 API를 이용해서 코드를 작성하게 됩니다.
  
  스프링 MVC의 기본 구조는 아래 그림과 같이 표현할 수 있습니다.
  
  ![22](https://user-images.githubusercontent.com/57030114/122505282-fc061300-d036-11eb-9c42-7a5a70417385.PNG)
  
  1. 사용자의 Request는 Front-Controller인 DispatcherServlet을 통해 처리합니다.
  
  2, 3. HandlerMapping은 Request의 처리를 담당하는 컨트롤러를 찾기 위해서 존재합니다. 
  HandlerMapping 인터페이스를 구현한 여러 객체들 중 RequestMappingHandlerMap-ping 같은 경우는 개발자가 @RequestMapping 어노테이션이 적용된 것을 기준으로 판단하게 됩니다. 
  적절한 컨트롤러가 찾아졌다면 HandlerAdapter를 이용해서 해당 컨트롤러를 동작시킵니다.
  
  4. Controller는 개발자가 작성하는 클래스로 실제 Request를 처리하는 로직을 작성하게 됩니다. View에 전달해야 하는 데이터는 주로 Model이라는 객체에 담아서 전달. 
  다양한 타입의 결과를 반환하는데 이에 대한 처리는 ViewResolver를 이용하게 됩니다. 
  
  5. ViewResolver는 Controller가 반환한 결과를 어떤 View를 통해서 처리하는 것이 좋을지 해석하는 역할을 합니다. 
  가장 흔한 설정은 servlet-context.xml에 정의된 Inter-nalResourceViewResolver입니다.
  
  6, 7. View는 실제로 응답을 보내야 하는 데이터를 Jsp 등을 이용해서 생성하는 역할을 하게 됩니다. 만들어진 응답은 DispathcherServlet을 통해서 전달됩니다.
  
  Request는 DispatcherServlet을 통하도록 설계되는데, 이런 방식을 Front-Controller 패턴, 이 패턴을 이용하는 경우에는 모든 Request의 처리에 대한 분배가 정해진 방식대로만 동작하기 때문에 좀 
  더 엄격한 구조를 만들어 낼 수 있습니다.
  
  스프링 MVC의 Controller의 특징
  1. HttpServletRequest, HttpServletResponse를 거의 사용할 필요 없이 필요한 기능 구현
  2. 다양한 타입의 파라미터 처리, 다양한 타입의 리턴 타입 사용 가능
  3. GET 방식, POST 방식 등 전송 방식에 대한 처리를 어노테이션으로 처리 가능
  4. 상속/인터페이스 방식 대신에 어노테이션만으로도 필요한 설정 가능
  
  @Controller, @RequestMapping
  @Controller : 자동으로 스프링의 객체로 등록
  @RequestMapping : 현재 클래스의 모든 메서드들의 기본적인 URL 경로가 됨. (클래스의 선언, 메서드 선언 사용 가능)
                    @RequestMapping의 경우 몇 가지의 속성을 추가할 수 있음. 주로 method 속성을 사용하는데 흔히 GET 방식, POST 방식을 구분해서 사용할 때 이용.
                    축약형으로 @GetMapping, @PostMapping, GET, POST 방식 모두를 지원해야 하는 경우 배열로 처리해서 지정할 수 있음.
  
  Controller를 작성할 때 가장 편리한 기능은 파라미터가 자동으로 수집되는 기능입니다. 예를 들어 SampleDTO에는 int 타입으로 선언된 age가 자동으로 숫자로 변환되는 것을 볼수 있음.
  만일 기본 자료형이나 문자열 등을 이용한다면 파라미터의 타입만을 맞게 선언해주는 방식을 사용할 수 있습니다.
  @RequestParam은 파라미터로 사용된 변수의 이름과 전달되는 파라미터의 이름이 다른 경우에 유용하게 사용됩니다.
  
  동일한 이름의 파라미터가 여러 개 전달되는 경우에는 ArrayList<> 등을 이용해서 처리가 가능합니다. 배열(예:String[])의 경우도 동일하게 처리할 수 있습니다. 
  
  만일 전달하는 데이터가 객체 타입이고 여러 개를 처리해야 한다면 약간의 작업을 통해서 한 번에 처리를 할 수 있습니다.
  
  @InitBinder : 변환이 가능한 데이터는 자동으로 변환되지만 경우에 따라서는 파라미터를 변환해서 처리해야 하는 경우도 존재합니다. 
  (예 : '2018-01-01'과 같은 문자열로 전달된 데이터를 java.util.Date) 타입으로 변환하는 작업이 그러함. 스프링 Controller에서는 파라미터를 바인딩할 때 자동으로 호출되는 
  @InitBinder를 이용해서 이러한 변환을 처리할 수 있습니다.
  
  @DateTimeFormat : @InitBinder를 이용해서 날짜를 변환할 수도 있지만, 파라미터로 사용되는 인스턴스 변수에 @DateTimeFormat을 적용해도 변환이 가능합니다.
  
  Controller의 메서드를 작성할 때는 특별하게 Model이라는 타입을 파라미터로 지정할 수 있습니다. Model 객체는 JSP에 컨트롤러에서 생성된 데이터를 담아서 전달하는 역할을 하는 존재입니다.
  메서트의 파라미터에 Model 타입이 지정된 경우에는 스프링은 특별하게 Model 타입의 객체를 만들어서 메서드에 주입하게 됩니다.

![11](https://user-images.githubusercontent.com/57030114/124386034-3f3cd300-dd13-11eb-900d-c84940f7dfe4.PNG)

  Model을 사용해야 하는 경우는 주로 Controller에 전달된 데이터를 이용해서 추가적인 데이터를 가져와야 하는 상황입니다.
  
  1. 리스트 페이지 번호를 파라미터로 전달받고, 실제 데이터를 View로 전달해야 하는 경우
  2. 파라미터들에 대한 처리 후 결과를 전달해야 하는 경우
  
  @ModelAttribute 어노테이션
  SampleDTO의 경우는 Java Bean의 규칙에 맞기 때문에 자동으로 다시 화면까지 전달됩니다. 전달될 때에는 클래스명의 앞글자는 소문자로 처리됩니다. 
  반면에 기본 자료형의 경우는 파라미터로 선언하더라도 기본적으로 화면까지 전달되지는 않습니다. 예를 들어 int 타입으로 선언된 변수는 전달되지 않습니다. 
  @ModelAttribute는 강제로 전달받은 파라미터를 Model에 담아서 전달하도록 할 때 필요한 어노테이션입니다. 
  @ModelAttribute가 걸린 파라미터는 타입에 관계없이 무조건 Model에 담아서 전달되므로, 파라미터로 전달된 데이터를 다시 화면에서 사용해야 할 경우에 유용하게 사용됩니다.
(기본 자료형에 @ModelAttribute를 적용할 경우에는 반드시 @ModelAttribute("page")와 같이 값(value)을 지정하도록 합니다.)
  
  Model 타입과 더불어서 스프링 MVC가 자동으로 전달해 주는 타입 중에는 RedirectAttributes 타입이 존재합니다. RedirectAttributes는 조금 특별하게도 일회성으로 데이터를 전달하는 용도로 
  사용됩니다. RedirectAttributes는 기존에 Servlet에서는 response.sendRedircet()를 사용할 때와 동일한 용도로 사용됩니다.
  
  ![11](https://user-images.githubusercontent.com/57030114/124612625-734bfb80-dead-11eb-8c4d-f22181a5628a.PNG)

  RedirectAttributes는 Model과 같이 파라미터로 선언해서 사용하고, addFlashAttribute(이름,값) 메서드를 이용해서 화면에 한 번만 사용하고 다음에는 사용되지 않는 데이터를 전달하기 위해서 
  사용합니다.
  
  스프링 MVC의 구조가 기존의 상속과 인터페이스에서 어노테이션을 사용하는 방식으로 변한 이후에 가장 큰 변화 중 하나는 리턴 타입이 자유로워 졌다는 점입니다.
  
  String : jsp를 이용하는 경우에는 jsp 파일의 경로와 파일이름을 나타내기 위해 사용합니다. 상황에 따라 다른 화면을 보여줄 필요가 있을 경우에 유용함.
  redirect, forward 키워드를 붙여서 사용가능.
  void : 호출하는 URL과 동일한 이름의 jsp를 의미합니다.
  VO, DTO 타입 : 주로 JSON 타입의 데이터를 만들어서 반환하는 용도로 사용합니다.
  ResponseEntity 타입 : response 할 때 Http 헤더 정보와 내용을 가공하는 용도로 사용합니다.
  Model, ModelAndView : Model로 데이터를 반환하거나 화면까지 같이 지정하는 경우에 사용합니다.
  HttpHeaders : 응답에 내용 없이 Http 헤더 메시지만 전달하는 용도로 사용합니다.
  
  commons-fileupload 파일 업로드 방식을 이용할 때, 파일 업로드의 경우에는 반드시 id 속성의 값을 multipartResolver로 정확하게 지정해야 함.(ex07)
  
  Controller를 작성할 때 예외 상황을 고려하면 처리해야 하는 작업이 너무 많아질 수밖에 없습니다.
  스프링 MVC에서는 이러한 작업을 다음과같은 방식으로 처리할 수 있습니다.
  @ExceptionHandler와 @ControllerAdvice를 이용한 처리
  @ResponseEntity를 이용하는 예외 메시지 구성

  @ControllerAdvice는 AOP를 이용하는 방식입니다. Controller를 작성할 때는 메소드의 모든 예외상황을 전부 핸들링해야 한다면 많은 양의 코드가 중복되겠지만, 
  AOP 방식을 이용하면 공통적인 예외상   황에 대해서는 별도로 @ControllerAdvice를 이용해서 분리합니다.
  
  @ControllerAdvice는 해당 객체가 스프링의 컨트롤러에서 발생하는 예외를 처리하는 존재임을 명시합니다.
  @ExceptionHandler는 어노테이션의 속성으로는 Exception 클래스 타입을 지정할 수 있습니다.

  WAS 구동 중에 에러과 관련된 HTTP 상태 코드 중 가장 흔한 코드는 '404'와 '500' 에러 코드입니다. 500 메시지는 'Internal Server Error' 이므로 @ExceptionHandler를 이용해서 처리되지만, 
  잘못된 URL을 호출했을 때 발생하는 404 에러 메시지는 다르게 처리하는 것이 좋습니다. 서블릿이나 JSP를 이용했던 개발 시에는 web.xml을 이용해서 별도의 에러 페이지를 지정할 수 있습니다. 
  에러 발생 시 추가적인 작업을 하기는 어렵기 때문에 스프링을 이용해서 404와 같이 WAS 내부에서 발생하는 에러를 처리하는 방식을 알아두는 것이 좋습니다.
 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PART 3 : 기본적인 웹 게시물 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 스프링 MVC 프로젝트의 기본 
  
  웹 프로젝트는 3-tier 방식으로 구성합니다.
  
  1. Presentation Tier(화면 계층)는 화면에 보여주는 기술을 사용하는 영역입니다. 프로젝트의 성격에 맞춰 앱으로 제작하거나, CS로 구성되는 경우도 있습니다. 
  2. Business Tier(비즈니스 계층)는 순수한 비즈니스 로직을 담고 있는 영역입니다. 이 영역이 중요한 이유는 고객이 원하는 요구 사항을 반영하는 계층이기 때문입니다.
  3. Persistence Tier(영속 계층 혹은 데이터 계층)는 데이터를 어떤 방식으로 보관하고, 사용하는가에 대한 설계가 들어가는 계층입니다. 일반적인 경우에는 데이터베이스를 많이 이용하지만, 경우에 
  따라서 네트워크 호출이나 원격 호출 등의 기술이 접목될 수 있습니다.
  ![KakaoTalk_20210207_141026062](https://user-images.githubusercontent.com/57030114/133594025-7afcae4a-fc07-4b8c-849b-ff884f7109f5.jpg)
  
  스프링 MVC 영역은 Presentation Tier를 구성하게 되는데, 각 영역은 사실 별도의 설정을 가지는 단위로 볼 수 있습니다. root-context.xml, servlet-context.xml 등의 설정 파일이 해당 영역의 설
  정을 담당하였습니다. 스프링 Core 영역은 POJO의 영역입니다. 스프링의 의존성 주입을 이용해서 객체 간의 연관구조를 완성해서 사용합니다. MyBatis 영역은 현실적으로는 mybatis-spring을 이용해서 
  구성하는 영역입니다. SQL에 대한 처리를 담당하는 구조입니다.
  
  3-tier로 구성하는 가장 일반적인 설명은 '유지 보수'에 대한 필요성 때문이다. 각 영역은 설계 당시부터 영역을 구분하고, 해당 연결 부위는 인터페이스를 이용해서 설계하는 것이 일반적인 구성방식입
  니다.
   네이밍 규칙 : 
  1. xxxController : 스프링 MVC에서 동작하는 Controller 클래스를 설계할 때 사용합니다.
  2. xxxSerivce, xxxServiceImpl : 비즈니스 영역을 담당하는 인터페이스는 'xxxService'라는 방식을 사용하고, 인터페이스를 구현한 클래스는 'xxxServiceImpl'이라는 이름을 사용합니다.
  3. xxxDAO, xxxRepository: DAO나 Repository라는 이름으로 영역을 따로 구성하는 것이 보편적입니다. 
  4. VO, DTO : VO와 DTO는 일반적으로 유사한 의미로 사용하는 용어로, 데이터를 담고 있는 객체를 의미한다는 공통점이 있습니다. 다만, VO의 경우는 주로 Read Only의 목적이 강하고, 데이터 자체도 
  불변하게 설계하는 것이 정석입니다. DTO는 주로 데이터 수집의 용도가 좀 더 강합니다. 
  
  패키지 구성은 규모가 작은 프로젝트는 Controller 영역을 별도의 패키지로 설계하고, Service 영역 등을 하나의 패키지로 설계할 수 있습니다. 반면에, 프로젝트의 규모가 커져서 많은 Service 클래스
  와 Controller들이 혼재할 수 있다면 비즈니스를 단위별로 구분하고 다시 내부에서 Controller 패키지, Serivce 패키지 등으로 다시 나누는 방식을 이용합니다.
  
![a](https://user-images.githubusercontent.com/57030114/133598380-f792a787-4647-4c67-8060-f6a4fac9a398.jpg)

  프로젝트를 진행하기 전에 고객의 요구사항을 인식하고, 이를 설계하는 과정이 필요합니다.
  요구사항은 실제로 상당히 방대해 질 수 있으므로, 프로젝트에서는 단계를 정확히 구분해 주는 것이 좋습니다.
  요구사항은 온전한 문장으로 정리하는 것이 좋습니다. 
  
  각 화면을 설계하는 단계에서는 사용자가 입력해야 하는 값과 함께 전체 페이지의 흐름이 설계됩니다. 이 화면의 흐름을 URL로 구성하게 되는데 이 경우 GET/POST 방식에 대해서 같이 언급해두는 것이  
  좋습니다.

  영속/비즈니스 계층의 CRUD 구현
  
  영속 계층의 작업은 항상 다음과 같은 순서로 진행합니다.
  1. 테이블의 컬럼 구조를 반영하는 VO 클래스의 생성
  2. MyBatis의 Mapper 인터페이스의 작성/XML 처리
  3. 작성한 Mapper 인터페이스의 테스트
  
  간단한 SQL이라면 어노테이션을 이용해서 처리하는 것이 무난하지만, SQL이 점점 복잡해지고 검색과 같이 상황에 따라 다른 SQL문이 처리되는 경우에는 어노테이션은 그다지 유용하지 못한다는 단점이 있
  습니다. XML의 경우 단순 텍스트를 수정하는 과정만으로 처리가 끝나지만, 어노테이션의 경우 코드를 수정하고 다시 빌드하는 등의 유지 보수성이 떨어지는 이유로 기피하는 경우도 종종 있습니다.
  
  Mapper 인터페이스를 작성할 때는 리스트(select)와 등록(insert) 작업을 우선해서 작성합니다.
  
  SQL를 작성할 때, SQL Developer에서 먼저 실행해서 결과를 확인해야한다. 이유는 1. SQL이 문제가 없이 실행 가능한지를 확인하기 위한 용도와 2. 데이터베이스의 commit을 하지 않았다면 나중에 
  테스트 결과가 달라지기 때문에 이를 먼저 비교할 수 있도록 하기 위함입니다.
  
  XML을 작성할 때는 반드시 <mapper>의 namespace 속성값을 Mapper 인터페이스와 동일한 이름을 주는 것에 주의하고, <select> 태그의 id 속성값은 메서드의 이름과 일치하게 작성합니다.
  resultType 속성의 값은 select 쿼리의 결과를 특정 클래스의 객체로 만들기 위해서 설정합니다.
  
  자동으로 PK 값이 정해지는 경우에는 1. insert만 처리되고 생성된 PK 값을 알 필요가 없는 경우 2. insert문이 실행되고 생성된 PK 값을 알아야 하는 경우
  insert문의 몇 건의 데이터가 변경되었는지만을 알려주기 때문에 추가된 데이터의 PK 값을 알 수는 없지만, 1번의 SQL 처리만으로 작업이 완료되는 장점이 있습니다.
  @SelectKey는 주로 PK 값을 미리 SQL을 통해서 처리해 두고 특정한 이름으로 결과를 보관하는 방식입니다. @SelectKey를 이용하는 방식은 SQL을 한 번 더 실행하는 부담이 있기는 하지만 자동으로 
  추가되는 PK 값을 확인해야 하는 상황에서는 유용하게 사용될 수 있습니다.
  
  
  등록, 삭제, 수정과 같은 DML 작업은 '몇 건의 데이터가 삭제(혹은 수정) 되었는지'를 반환할 수 있습니다. Update는 delete와 마찬가지로 int 타입으로 메서드를 설계할 수 있습니다.
  
  
  비즈니스 계층
  
  
  비즈니스 계층은 고객의 요구사항을 반영하는 계층으로 프레젠테이션 계층과 영속 계층의 중간 다리 역할을 하게 됩니다. 영속 계층은 데이터베이스를 기준으로 해서 설계를 나눠 구현하지만, 비즈니스
  계층은 로직을 기준으로 해서 처리하게 됩니다. 일반적으로는 비즈니스 영역에 있는 객체들은 '서비스(Service)'라는 용어를 많이 사용합니다.
  
  설계를 할 때 각 계층 간의 연결은 인터페이스를 이용해서 느슨한(loose) 연결(결합)을 합니다. 인터페이스와 인터페이스를 구현한 클래스를 선언합니다.
  인터페이스를 구현한 클래스에 가장 중요한 부분은 @Service라는 어노테이션입니다. @Service는 계층 구조상 주로 비즈니스 영역을 담당하는 객체임을 표시하기 위해 사용합니다.
  
  프레젼테이션(웹) 계층의 CRUD 구현
  
  
  
